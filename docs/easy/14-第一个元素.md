---
title: 14-第一个元素
lang: zh-CN
---

# {{ $frontmatter.title }}

## 题目描述

实现一个通用`First<T>`，它接受一个数组`T`并返回它的第一个元素的类型。

例如：

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

type head1 = First<arr1> // expected to be 'a'
type head2 = First<arr2> // expected to be 3
```


## 分析

这一题主要是围绕元组的，要获取元组的第一个，就必须要借助 ts 的 `infer` 了。

这一类题的套路都如下：`T extends [infer F, ...infer R] ? F : never`。

其本质可以说是模式匹配，如果 `T` 能够匹配上 `[infer F, ...infer R]`，那么就取前一个类型，否则走后者，基本逻辑和 js 中的三元表达式一样。

关于 `extends` 这种三元表达式的用法，可以参考 [conditional-types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)。

## 题解

了解了 infer 和 extends 用法后，其实答案也非常简单了：

```ts
// ============= Test Cases =============
import type { Equal, Expect } from './test-utils'

type cases = [
  Expect<Equal<First<[3, 2, 1]>, 3>>,
  Expect<Equal<First<[() => 123, { a: string }]>, () => 123>>,
  Expect<Equal<First<[]>, never>>,
  Expect<Equal<First<[undefined]>, undefined>>,
]

type errors = [
  // @ts-expect-error
  First<'notArray'>,
  // @ts-expect-error
  First<{ 0: 'arrayLike' }>,
]

// ============= Your Code Here =============
type First<T extends any[]> = T extends [infer F, ...infer R] ? F : never;
```

这里值得一提的就是 `[] extends [infer F, ...infer R]` 的判断，由于有两个变量需要推断，`F` 和 `R`，但是原数组中一个元素都没有，此时就会走 false 的逻辑，返回 never。而如果有一个元素，那么还是会走 true 的逻辑，此时 `R` 会被推断为 `[]`。

## 知识点

1. xxx extends infer xxx ? A : B，infer + extends 范式
2. [infer F, ...infer R] 中，如果1个元素都没有，那么走 false 的逻辑


